<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bluesky Stream Monitor</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #0a0a0a;
        color: #e0e0e0;
        min-height: 100vh;
        padding: 2rem;
      }
      .header {
        text-align: center;
        margin-bottom: 2rem;
      }
      .header h1 {
        font-size: 1.5rem;
        font-weight: 600;
        margin-bottom: 0.25rem;
      }
      .header p {
        color: #666;
        font-size: 0.875rem;
      }
      .live-counters {
        display: flex;
        flex-wrap: nowrap;
        gap: 1rem;
        justify-content: center;
        align-items: stretch;
        margin: 0 auto 1.5rem auto;
        max-width: 900px;
      }
      .session-label {
        width: 100%;
        text-align: center;
        font-size: 0.75rem;
        color: #555;
        margin-bottom: 0.25rem;
        flex-shrink: 0;
      }
      .counter {
        background: #1a1a1a;
        border-radius: 12px;
        padding: 1.5rem;
        text-align: center;
        border: 1px solid #333;
        flex: 1 1 0;
        min-width: 0;
      }
      .counter .label {
        font-size: 0.875rem;
        color: #888;
        margin-bottom: 0.5rem;
      }
      .counter .value {
        font-size: 2rem;
        font-weight: 700;
        font-variant-numeric: tabular-nums;
      }
      .counter .rate {
        font-size: 0.875rem;
        color: #666;
        margin-top: 0.25rem;
      }
      .counter .stats-row {
        display: flex;
        justify-content: space-around;
        margin-top: 0.75rem;
        padding-top: 0.75rem;
        border-top: 1px solid #333;
      }
      .counter .stat-item {
        font-size: 0.7rem;
        color: #666;
      }
      .counter .stat-value {
        color: #aaa;
        font-weight: 600;
        display: block;
      }
      .counter .stat-value.good { color: #4ade80; }
      .counter .stat-value.warning { color: #fbbf24; }
      .counter .stat-value.bad { color: #f87171; }
      .counter .connection-status {
        font-size: 0.7rem;
        margin-top: 0.5rem;
      }
<<<<<<< Updated upstream
      .counter .uptime {
        font-size: 0.75rem;
        color: #4ade80;
        margin-top: 0.25rem;
      }
      .counter .uptime.disconnected {
        color: #f87171;
      }
      .counter .connection-dot {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #4ade80;
        margin-right: 4px;
      }
      .counter .connection-dot.disconnected {
        background: #f87171;
      }
=======
      .counter .connection-status.connected { color: #4ade80; }
      .counter .connection-status.disconnected { color: #f87171; }
>>>>>>> Stashed changes
      .counter.winning {
        border-color: #4ade80;
        box-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
      }
      .counter.winning .value { color: #4ade80; }
      .counter.losing {
        border-color: #f87171;
        box-shadow: 0 0 20px rgba(248, 113, 113, 0.3);
      }
      .counter.losing .value { color: #f87171; }
      .delta {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 1rem 1.5rem;
        flex: 0 0 140px;
        min-width: 180px;
      }
      .delta .value { font-variant-numeric: tabular-nums; }
      .delta .label { font-size: 0.75rem; color: #666; }
      .delta .value { font-size: 1.5rem; font-weight: 600; }
      .delta.positive .value { color: #4ade80; }
      .delta.negative .value { color: #f87171; }
      .delta.neutral .value { color: #888; }
      
      .section-title {
        font-size: 0.875rem;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        margin: 2rem 0 1rem 0;
        text-align: center;
      }
      
      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 1rem;
        max-width: 1400px;
        margin: 0 auto 1.5rem auto;
      }
      
      .metric-card {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 12px;
        padding: 1.25rem;
      }
      .metric-card h3 {
        font-size: 0.75rem;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 1rem;
      }
      .metric-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.4rem 0;
        border-bottom: 1px solid #2a2a2a;
      }
      .metric-row:last-child { border-bottom: none; }
      .metric-label {
        font-size: 0.8rem;
        color: #888;
      }
      .metric-value {
        font-size: 0.9rem;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
      }
      .metric-value.good { color: #4ade80; }
      .metric-value.warning { color: #fbbf24; }
      .metric-value.bad { color: #f87171; }
      
      .uptime-mini-bar {
        width: 60px;
        height: 6px;
        background: #333;
        border-radius: 3px;
        overflow: hidden;
        display: inline-block;
        vertical-align: middle;
        margin-left: 8px;
      }
      .uptime-mini-bar-fill {
        height: 100%;
        border-radius: 3px;
      }
      
      .charts-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: 1.5rem;
        max-width: 1400px;
        margin: 0 auto;
      }
      .chart-panel {
        background: #1a1a1a;
        border-radius: 12px;
        padding: 1.5rem;
        border: 1px solid #333;
      }
      .chart-panel h2 {
        font-size: 0.875rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: #888;
      }
      .chart-wrapper {
        height: 200px;
        position: relative;
        width: 100%;
      }
      
      .status {
        position: fixed;
        bottom: 1rem;
        right: 1rem;
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        font-size: 0.75rem;
        background: #1a1a1a;
        border: 1px solid #333;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .status .duration { font-size: 0.65rem; color: #666; }
      .status.connected { color: #4ade80; }
      .status.disconnected { color: #f87171; }
      
      @media (max-width: 900px) {
        body { padding: 1rem; }
        .live-counters { flex-direction: column; gap: 0.75rem; }
        .counter, .delta { flex: 1 1 100%; width: 100%; }
        .charts-container { grid-template-columns: 1fr; }
        .chart-panel { min-width: 0; }
        .chart-wrapper { height: 180px; }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>Stream Monitor</h1>
      <p>Real-time Bluesky Jetstream monitoring</p>
    </div>

    <div class="session-label">Live Metrics</div>
    <div class="live-counters">
      <div class="counter" id="counter-a">
        <div class="label" id="label-a">Stream A</div>
        <div class="value" id="count-a">0</div>
        <div class="rate" id="rate-a">0/s</div>
<<<<<<< Updated upstream
        <div class="uptime" id="uptime-a">-</div>
=======
        <div class="stats-row">
          <div class="stat-item">
            <span class="stat-value" id="latency-a">-</span>
            Latency
          </div>
          <div class="stat-item">
            <span class="stat-value" id="streak-a">-</span>
            Streak
          </div>
          <div class="stat-item">
            <span class="stat-value" id="uptime-a">-</span>
            Uptime
          </div>
        </div>
        <div class="connection-status connected" id="conn-status-a">● Connected</div>
>>>>>>> Stashed changes
      </div>
      
      <div class="delta neutral" id="delta">
        <div class="label">Delta</div>
        <div class="value" id="delta-value">0</div>
      </div>
      
      <div class="counter" id="counter-b">
        <div class="label" id="label-b">Stream B</div>
        <div class="value" id="count-b">0</div>
        <div class="rate" id="rate-b">0/s</div>
<<<<<<< Updated upstream
        <div class="uptime" id="uptime-b">-</div>
=======
        <div class="stats-row">
          <div class="stat-item">
            <span class="stat-value" id="latency-b">-</span>
            Latency
          </div>
          <div class="stat-item">
            <span class="stat-value" id="streak-b">-</span>
            Streak
          </div>
          <div class="stat-item">
            <span class="stat-value" id="uptime-b">-</span>
            Uptime
          </div>
        </div>
        <div class="connection-status connected" id="conn-status-b">● Connected</div>
>>>>>>> Stashed changes
      </div>
    </div>

    <div class="section-title">Uptime Dashboard</div>
    <div class="metrics-grid">
      <div class="metric-card">
        <h3>24-Hour Summary</h3>
        <div class="metric-row">
          <span class="metric-label" id="uptime24-label-a">Stream A Uptime</span>
          <span class="metric-value good" id="uptime24-a">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label" id="uptime24-label-b">Stream B Uptime</span>
          <span class="metric-value good" id="uptime24-b">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream A Total Up</span>
          <span class="metric-value" id="uptime24-total-a">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream B Total Up</span>
          <span class="metric-value" id="uptime24-total-b">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream A Disconnects</span>
          <span class="metric-value" id="uptime24-disc-a">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream B Disconnects</span>
          <span class="metric-value" id="uptime24-disc-b">-</span>
        </div>
      </div>
      
      <div class="metric-card">
        <h3>28-Day Summary</h3>
        <div class="metric-row">
          <span class="metric-label" id="uptime28-label-a">Stream A Uptime</span>
          <span class="metric-value good" id="uptime28-a">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label" id="uptime28-label-b">Stream B Uptime</span>
          <span class="metric-value good" id="uptime28-b">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream A Total Up</span>
          <span class="metric-value" id="uptime28-total-a">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream B Total Up</span>
          <span class="metric-value" id="uptime28-total-b">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream A Disconnects</span>
          <span class="metric-value" id="uptime28-disc-a">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream B Disconnects</span>
          <span class="metric-value" id="uptime28-disc-b">-</span>
        </div>
      </div>
      
      <div class="metric-card">
        <h3>Message Rate (24h)</h3>
        <div class="metric-row">
          <span class="metric-label" id="rate24-label-a">Stream A Avg</span>
          <span class="metric-value" id="rate24-a">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label" id="rate24-label-b">Stream B Avg</span>
          <span class="metric-value" id="rate24-b">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream A Total Msgs</span>
          <span class="metric-value" id="msgs24-a">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream B Total Msgs</span>
          <span class="metric-value" id="msgs24-b">-</span>
        </div>
      </div>
      
      <div class="metric-card">
        <h3>Latency</h3>
        <div class="metric-row">
          <span class="metric-label" id="lat-label-a">Stream A Avg</span>
          <span class="metric-value" id="lat24-a">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label" id="lat-label-b">Stream B Avg</span>
          <span class="metric-value" id="lat24-b">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream A Current</span>
          <span class="metric-value" id="lat-current-a">-</span>
        </div>
        <div class="metric-row">
          <span class="metric-label">Stream B Current</span>
          <span class="metric-value" id="lat-current-b">-</span>
        </div>
      </div>
    </div>

    <div class="charts-container">
      <div class="chart-panel">
        <h2 id="uptime-chart-24h-title">Uptime % (24h)</h2>
        <div class="chart-wrapper">
          <canvas id="chart-uptime-24h"></canvas>
        </div>
      </div>
      <div class="chart-panel">
        <h2 id="uptime-chart-28d-title">Uptime % (28 days)</h2>
        <div class="chart-wrapper">
          <canvas id="chart-uptime-28d"></canvas>
        </div>
      </div>
      <div class="chart-panel">
        <h2 id="rate-chart-24h-title">Message Rate (24h)</h2>
        <div class="chart-wrapper">
          <canvas id="chart-rate-24h"></canvas>
        </div>
      </div>
      <div class="chart-panel">
        <h2 id="latency-chart-title">Latency History</h2>
        <div class="chart-wrapper">
          <canvas id="chart-latency"></canvas>
        </div>
      </div>
    </div>

    <div class="status disconnected" id="status">
      <span class="indicator">Disconnected</span>
      <span class="duration" id="status-duration"></span>
    </div>

    <script>
      const labelA = document.getElementById("label-a");
      const labelB = document.getElementById("label-b");
      const countA = document.getElementById("count-a");
      const countB = document.getElementById("count-b");
      const rateA = document.getElementById("rate-a");
      const rateB = document.getElementById("rate-b");
<<<<<<< Updated upstream
      const uptimeA = document.getElementById("uptime-a");
      const uptimeB = document.getElementById("uptime-b");
=======
      const latencyA = document.getElementById("latency-a");
      const latencyB = document.getElementById("latency-b");
      const streakA = document.getElementById("streak-a");
      const streakB = document.getElementById("streak-b");
      const uptimeA = document.getElementById("uptime-a");
      const uptimeB = document.getElementById("uptime-b");
      const connStatusA = document.getElementById("conn-status-a");
      const connStatusB = document.getElementById("conn-status-b");
>>>>>>> Stashed changes
      const counterA = document.getElementById("counter-a");
      const counterB = document.getElementById("counter-b");
      const deltaEl = document.getElementById("delta");
      const deltaValue = document.getElementById("delta-value");
      const statusEl = document.getElementById("status");
      const statusIndicator = statusEl.querySelector(".indicator");
      const statusDuration = document.getElementById("status-duration");

      let connectedAt = null;
      let streamAName = "Stream A";
      let streamBName = "Stream B";
<<<<<<< Updated upstream
      let rawData24h = [];
      let rawData28d = [];
      let uptimeData24h = [];
      let uptimeData28d = [];
=======
      let rawUptimeData24h = [];
      let rawUptimeData28d = [];
      let uptimeDetailed = null;
>>>>>>> Stashed changes

      function formatDuration(ms) {
        const secs = Math.floor(ms / 1000);
        const hrs = Math.floor(secs / 3600);
        const mins = Math.floor((secs % 3600) / 60);
        if (hrs > 0) return `${hrs}h ${mins}m`;
        if (mins > 0) return `${mins}m ${secs % 60}s`;
        return `${secs}s`;
      }

<<<<<<< Updated upstream
      function formatUptimePercentage(seconds, periodSeconds = 3600) {
        const percentage = (seconds / periodSeconds) * 100;
        return percentage.toFixed(1) + "%";
=======
      function formatDurationLong(seconds) {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        if (hrs > 0) return `${hrs}h ${mins}m ${secs}s`;
        if (mins > 0) return `${mins}m ${secs}s`;
        return `${secs}s`;
      }

      function formatUptimePercentage(seconds, periodSeconds = 3600) {
        const percentage = (seconds / periodSeconds) * 100;
        return percentage.toFixed(2) + "%";
      }

      function getUptimeClass(percentage) {
        if (percentage >= 99) return "good";
        if (percentage >= 95) return "warning";
        return "bad";
      }

      function getLatencyClass(ms) {
        if (ms < 100) return "good";
        if (ms < 200) return "warning";
        return "bad";
>>>>>>> Stashed changes
      }

      setInterval(() => {
        if (connectedAt) {
          statusDuration.textContent = formatDuration(Date.now() - connectedAt);
        }
      }, 1000);

      function updateLabels() {
        document.getElementById("uptime24-label-a").textContent = streamAName + " Uptime";
        document.getElementById("uptime24-label-b").textContent = streamBName + " Uptime";
        document.getElementById("uptime28-label-a").textContent = streamAName + " Uptime";
        document.getElementById("uptime28-label-b").textContent = streamBName + " Uptime";
        document.getElementById("rate24-label-a").textContent = streamAName + " Avg";
        document.getElementById("rate24-label-b").textContent = streamBName + " Avg";
        document.getElementById("lat-label-a").textContent = streamAName + " Avg";
        document.getElementById("lat-label-b").textContent = streamBName + " Avg";
      }

      function createUptimeChart(canvasId, titleId, title) {
        return new Chart(document.getElementById(canvasId), {
          type: "bar",
          data: { labels: [], datasets: [] },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: true, position: "top", labels: { color: "#888", boxWidth: 12 } },
              tooltip: { backgroundColor: "#2a2a2a", titleColor: "#e0e0e0", bodyColor: "#888" }
            },
            scales: {
              x: { ticks: { color: "#666", maxTicksLimit: 12 }, grid: { display: false } },
              y: { 
                ticks: { color: "#666", callback: v => v + "%" }, 
                grid: { color: "#222" },
                min: 0, max: 100 
              }
            }
          }
        });
      }

      function createRateChart(canvasId, titleId, title) {
        return new Chart(document.getElementById(canvasId), {
          type: "line",
          data: { labels: [], datasets: [] },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: true, position: "top", labels: { color: "#888", boxWidth: 12 } },
              tooltip: { backgroundColor: "#2a2a2a", titleColor: "#e0e0e0", bodyColor: "#888" }
            },
            scales: {
              x: { ticks: { color: "#666", maxTicksLimit: 12 }, grid: { display: false } },
              y: { ticks: { color: "#666", callback: v => v + "/s" }, grid: { color: "#222" } }
            }
          }
        });
      }

      function createLatencyChart(canvasId, titleId, title) {
        return new Chart(document.getElementById(canvasId), {
          type: "line",
          data: { labels: [], datasets: [] },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: true, position: "top", labels: { color: "#888", boxWidth: 12 } },
              tooltip: { backgroundColor: "#2a2a2a", titleColor: "#e0e0e0", bodyColor: "#888" }
            },
            scales: {
              x: { ticks: { color: "#666", maxTicksLimit: 12 }, grid: { display: false } },
              y: { ticks: { color: "#666", callback: v => v + "ms" }, grid: { color: "#222" } }
            }
          }
        });
      }

      const chartUptime24h = createUptimeChart("chart-uptime-24h", "uptime-chart-24h-title", "Uptime % (24h)");
      const chartUptime28d = createUptimeChart("chart-uptime-28d", "uptime-chart-28d-title", "Uptime % (28 days)");
      const chartRate24h = createRateChart("chart-rate-24h", "rate-chart-24h-title", "Message Rate (24h)");
      const chartLatency = createLatencyChart("chart-latency", "latency-chart-title", "Latency History");

      async function fetchDetailedUptime() {
        try {
          const res = await fetch("/api/uptime-detailed?hours=24");
          uptimeDetailed = await res.json();
          updateDetailedDisplay();
        } catch (e) {
          console.error("Failed to fetch detailed uptime:", e);
        }
      }

<<<<<<< Updated upstream
      function refreshCharts() {
        fetchHistory(24, chart24h, rawData24h);
        fetchHistory(672, chart28d, rawData28d);
        fetchUptime(24);
        fetchUptime(672);
      }

      async function fetchUptime(hours) {
        try {
          const res = await fetch(`/api/uptime?hours=${hours}`);
          const data = await res.json();

          if (hours <= 24) {
            uptimeData24h = data;
          } else {
            uptimeData28d = data;
          }

          updateUptimeDisplay(hours);
        } catch (e) {
          console.error("Failed to fetch uptime:", e);
        }
      }

      function updateUptimeDisplay(hours) {
        const data = hours <= 24 ? uptimeData24h : uptimeData28d;
        if (data.length === 0) return;

        const periodSeconds = hours * 3600;
        let totalA = 0;
        let totalB = 0;

        data.forEach(d => {
          totalA += d.stream_a_seconds;
          totalB += d.stream_b_seconds;
        });

        const percentageA = (totalA / periodSeconds) * 100;
        const percentageB = (totalB / periodSeconds) * 100;

        if (hours <= 24) {
          uptimeA.textContent = formatUptimePercentage(totalA, periodSeconds);
          uptimeB.textContent = formatUptimePercentage(totalB, periodSeconds);
=======
      async function fetchUptimeHistory(hours, uptimeChart, rateChart, latencyChart) {
        try {
          const res = await fetch(`/api/uptime?hours=${hours}`);
          const data = await res.json();
          
          if (data.length === 0) return;
          
          const labels = data.map(d => {
            const date = new Date(d.hour);
            return hours <= 24 
              ? date.toLocaleString("en-US", { month: "short", day: "numeric", hour: "2-digit" })
              : date.toLocaleDateString("en-US", { month: "short", day: "numeric" });
          });

          const uptimeA = data.map(d => (d.stream_a_seconds / 3600) * 100);
          const uptimeB = data.map(d => (d.stream_b_seconds / 3600) * 100);

          if (uptimeChart && hours <= 24) {
            uptimeChart.data.labels = labels;
            uptimeChart.data.datasets = [
              { label: streamAName, data: uptimeA, backgroundColor: "rgba(74, 222, 128, 0.7)", borderColor: "#4ade80", borderWidth: 1 },
              { label: streamBName, data: uptimeB, backgroundColor: "rgba(59, 130, 246, 0.7)", borderColor: "#3b82f6", borderWidth: 1 }
            ];
            uptimeChart.update("none");
          } else if (uptimeChart) {
            const dailyUptime = {};
            data.forEach(d => {
              const day = new Date(d.hour).toISOString().split("T")[0];
              if (!dailyUptime[day]) dailyUptime[day] = { a: 0, b: 0, count: 0 };
              dailyUptime[day].a += d.stream_a_seconds;
              dailyUptime[day].b += d.stream_b_seconds;
              dailyUptime[day].count++;
            });
            const days = Object.keys(dailyUptime).slice(-28);
            uptimeChart.data.labels = days;
            uptimeChart.data.datasets = [
              { label: streamAName, data: days.map(d => (dailyUptime[d].a / (dailyUptime[d].count * 3600)) * 100), backgroundColor: "rgba(74, 222, 128, 0.7)", borderColor: "#4ade80", borderWidth: 1 },
              { label: streamBName, data: days.map(d => (dailyUptime[d].b / (dailyUptime[d].count * 3600)) * 100), backgroundColor: "rgba(59, 130, 246, 0.7)", borderColor: "#3b82f6", borderWidth: 1 }
            ];
            uptimeChart.update("none");
          }

          if (rateChart && hours <= 24) {
            const messagesA = data.map(d => d.stream_a_messages || 0);
            const messagesB = data.map(d => d.stream_b_messages || 0);
            rateChart.data.labels = labels;
            rateChart.data.datasets = [
              { label: streamAName, data: messagesA.map((m, i) => m / 3600), borderColor: "#4ade80", backgroundColor: "transparent", tension: 0.3 },
              { label: streamBName, data: messagesB.map((m, i) => m / 3600), borderColor: "#3b82f6", backgroundColor: "transparent", tension: 0.3 }
            ];
            rateChart.update("none");
          }

          if (latencyChart && hours <= 24) {
            const latA = data.map(d => d.stream_a_latency_ms || 0);
            const latB = data.map(d => d.stream_b_latency_ms || 0);
            latencyChart.data.labels = labels;
            latencyChart.data.datasets = [
              { label: streamAName, data: latA, borderColor: "#4ade80", backgroundColor: "transparent", tension: 0.3 },
              { label: streamBName, data: latB, borderColor: "#3b82f6", backgroundColor: "transparent", tension: 0.3 }
            ];
            latencyChart.update("none");
          }

          if (hours <= 24) {
            rawUptimeData24h = data;
            calculate24hStats(data);
          } else {
            rawUptimeData28d = data;
          }
        } catch (e) {
          console.error("Failed to fetch uptime history:", e);
>>>>>>> Stashed changes
        }
      }

      function calculate24hStats(data) {
        if (data.length === 0) return;
        
        let totalA = 0, totalB = 0;
        let disconnectsA = 0, disconnectsB = 0;
        let messagesA = 0, messagesB = 0;
        let latencyA = 0, latencyB = 0;
        let latencyCountA = 0, latencyCountB = 0;
        
        data.forEach(d => {
          totalA += d.stream_a_seconds || 0;
          totalB += d.stream_b_seconds || 0;
          disconnectsA += d.stream_a_disconnects || 0;
          disconnectsB += d.stream_b_disconnects || 0;
          messagesA += d.stream_a_messages || 0;
          messagesB += d.stream_b_messages || 0;
          if (d.stream_a_latency_ms) { latencyA += d.stream_a_latency_ms; latencyCountA++; }
          if (d.stream_b_latency_ms) { latencyB += d.stream_b_latency_ms; latencyCountB++; }
        });

        const uptimeA = (totalA / (24 * 3600)) * 100;
        const uptimeB = (totalB / (24 * 3600)) * 100;
        
        const el = (id, val) => document.getElementById(id);
        el("uptime24-a").textContent = formatUptimePercentage(totalA, 24 * 3600);
        el("uptime24-b").textContent = formatUptimePercentage(totalB, 24 * 3600);
        el("uptime24-a").className = "metric-value " + getUptimeClass(uptimeA);
        el("uptime24-b").className = "metric-value " + getUptimeClass(uptimeB);
        
        el("uptime24-total-a").textContent = formatDurationLong(totalA);
        el("uptime24-total-b").textContent = formatDurationLong(totalB);
        
        el("uptime24-disc-a").textContent = disconnectsA;
        el("uptime24-disc-b").textContent = disconnectsB;
        
        if (messagesA > 0 && totalA > 0) {
          el("rate24-a").textContent = (messagesA / totalA).toFixed(1) + "/s";
        }
        if (messagesB > 0 && totalB > 0) {
          el("rate24-b").textContent = (messagesB / totalB).toFixed(1) + "/s";
        }
        
        el("msgs24-a").textContent = messagesA.toLocaleString();
        el("msgs24-b").textContent = messagesB.toLocaleString();
        
        if (latencyCountA > 0) {
          el("lat24-a").textContent = Math.round(latencyA / latencyCountA) + "ms";
          el("lat24-a").className = "metric-value " + getLatencyClass(latencyA / latencyCountA);
        }
        if (latencyCountB > 0) {
          el("lat24-b").textContent = Math.round(latencyB / latencyCountB) + "ms";
          el("lat24-b").className = "metric-value " + getLatencyClass(latencyB / latencyCountB);
        }
      }

      function updateDetailedDisplay() {
        if (!uptimeDetailed) return;
        
        document.getElementById("lat-current-a").textContent = uptimeDetailed.avg_latency_a_ms + "ms";
        document.getElementById("lat-current-b").textContent = uptimeDetailed.avg_latency_b_ms + "ms";
        document.getElementById("lat-current-a").className = "metric-value " + getLatencyClass(uptimeDetailed.avg_latency_a_ms);
        document.getElementById("lat-current-b").className = "metric-value " + getLatencyClass(uptimeDetailed.avg_latency_b_ms);
      }

      function refreshData() {
        fetchDetailedUptime();
        fetchUptimeHistory(24, chartUptime24h, chartRate24h, chartLatency);
        fetchUptimeHistory(672, chartUptime28d, null, null);
      }

      refreshData();
      setInterval(refreshData, 60000);

      function connect() {
        const ws = new WebSocket(location.origin.replace("http", "ws") + "/ws");

        ws.onopen = () => {
          connectedAt = Date.now();
          statusIndicator.textContent = "Connected";
          statusEl.className = "status connected";
          statusDuration.textContent = "0s";
        };

        ws.onclose = () => {
          connectedAt = null;
          statusIndicator.textContent = "Disconnected";
          statusEl.className = "status disconnected";
          statusDuration.textContent = "";
          setTimeout(connect, 1000);
        };

        ws.onmessage = (e) => {
          const stats = JSON.parse(e.data);

          if (streamAName !== stats.stream_a_name || streamBName !== stats.stream_b_name) {
            streamAName = stats.stream_a_name;
            streamBName = stats.stream_b_name;
            labelA.textContent = streamAName;
            labelB.textContent = streamBName;
            updateLabels();
          }

          labelA.textContent = stats.stream_a_name;
          labelB.textContent = stats.stream_b_name;
          countA.textContent = stats.stream_a.toLocaleString();
          countB.textContent = stats.stream_b.toLocaleString();
          rateA.textContent = Math.round(stats.rate_a).toLocaleString() + "/s";
          rateB.textContent = Math.round(stats.rate_b).toLocaleString() + "/s";

          const uptimePercentA = formatUptimePercentage(stats.uptime_a, 3600);
          const uptimePercentB = formatUptimePercentage(stats.uptime_b, 3600);
<<<<<<< Updated upstream
          uptimeA.textContent = (stats.connected_a ? "" : "⏸ ") + uptimePercentA;
          uptimeB.textContent = (stats.connected_b ? "" : "⏸ ") + uptimePercentB;
          uptimeA.className = stats.connected_a ? "uptime" : "uptime disconnected";
          uptimeB.className = stats.connected_b ? "uptime" : "uptime disconnected";
=======
          uptimeA.textContent = uptimePercentA;
          uptimeB.textContent = uptimePercentB;
          
          latencyA.textContent = stats.latency_a_ms + "ms";
          latencyA.className = "stat-value " + getLatencyClass(stats.latency_a_ms);
          latencyB.textContent = stats.latency_b_ms + "ms";
          latencyB.className = "stat-value " + getLatencyClass(stats.latency_b_ms);
          
          streakA.textContent = formatDuration(stats.current_streak_a * 1000);
          streakB.textContent = formatDuration(stats.current_streak_b * 1000);

          if (stats.connected_a) {
            connStatusA.textContent = "● Connected";
            connStatusA.className = "connection-status connected";
            uptimeA.className = "stat-value good";
          } else {
            connStatusA.textContent = "⏸ Disconnected";
            connStatusA.className = "connection-status disconnected";
            uptimeA.className = "stat-value bad";
          }
          
          if (stats.connected_b) {
            connStatusB.textContent = "● Connected";
            connStatusB.className = "connection-status connected";
            uptimeB.className = "stat-value good";
          } else {
            connStatusB.textContent = "⏸ Disconnected";
            connStatusB.className = "connection-status disconnected";
            uptimeB.className = "stat-value bad";
          }
>>>>>>> Stashed changes

          const delta = stats.delta;
          const sign = delta >= 0 ? "+" : "";
          deltaValue.textContent = sign + delta.toLocaleString();

          if (delta > 0) {
            deltaEl.className = "delta positive";
            counterA.className = "counter winning";
            counterB.className = "counter losing";
          } else if (delta < 0) {
            deltaEl.className = "delta negative";
            counterA.className = "counter losing";
            counterB.className = "counter winning";
          } else {
            deltaEl.className = "delta neutral";
            counterA.className = "counter";
            counterB.className = "counter";
          }
        };
      }

      connect();
    </script>
  </body>
</html>
